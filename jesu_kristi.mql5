//+------------------------------------------------------------------+
//|                                                 jesus_kristi.mq5 |
//|                                  Copyright 2024, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"

#include <Trade\Trade.mqh>

struct OrderParams {
  double volume;
  double price;
  double tp;
  double sl;
};

CTrade trade;
string tradeComment = "Detty December";
double riskPercent = 1.0;
string symbols[] = {
  "XAUUSDm",
  "NZDUSDm",
  "NZDJPYm",
  "EURJPYm",
  "USDJPYm",
  "AUDJPYm",
  "CHFJPYm",
  "AUDUSDm",
  "CADJPYm", 
  "GBPJPYm",
  "BTCUSDm",
  "EURNZDm",
  "GBPNZDm",
  "EURGBPm",
  "GBPCADm"
};
// string symbols[] = {
//   "XAUUSD",
//   "NZDUSD",
//   "NZDJPY",
//   "EURJPY",
//   "USDJPY",
//   "AUDJPY",
//   "CHFJPY",
//   "AUDUSD",
//   "CADJPY", 
//   "GBPJPY",
//   "BTCUSD",
//   "EURNZD",
//   "GBPNZD",
//   "EURGBP",
//   "GBPCAD"
// };
// string symbols[] = {
//   "Volatility 10 Index",
//   "Volatility 25 Index",
//   "Volatility 50 Index",
//   "Volatility 75 Index",
//   "Volatility 100 Index",
//   "Volatility 10 (1s) Index",
//   "Volatility 25 (1s) Index",
//   "Volatility 50 (1s) Index",
//   "Volatility 300 (1s) Index",
//   "Volatility 75 (1s) Index",
//   "Volatility 100 (1s) Index",
//   "Volatility 150 (1s) Index",
//   "Volatility 250 (1s) Index",
//   "Volatility 200 (1s) Index",
//   "Boom 500 Index",
//   "Boom 300 Index",
//   "Boom 1000 Index",
//   "Crash 500 Index",
//   "Crash 300 Index",
//   "Crash 1000 Index",
//   "Step Index",
//   "Step Index 200",
//   "Step Index 500",
//   "Range Break 100 Index",
//   "Range Break 200 Index",
//   "Jump 25 Index",
//   "Jump 10 Index",
//   "Jump 50 Index",
//   "Jump 100 Index",
//   "Jump 75 Index",
//   "DEX 600 DOWN Index",
//   "DEX 900 DOWN Index",
//   "DEX 1500 DOWN Index",
//   "DEX 600 UP Index",
//   "DEX 900 UP Index",
//   "DEX 1500 UP Index",
//   "Drift Switch Index 30",
//   "Drift Switch Index 20",
//   "Drift Switch Index 10"
// };
string signals[];



//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   return(INIT_SUCCEEDED);
  }

  void NotifyTheBoss(string type, string symbol)
    {
      string url = "https://webhook.site/15a9dca5-577b-4bce-a083-2eac4740e0ac";
      uchar result[];
      string responseHeaders;
      string headers = "Content-Type: application/json\r\n";
      string jsonPayload = "{\"users\":[{\"tokens\":[\"dRNwxoUzQuWr-EcWfVyBwY:APA91bEJQJv0GPhkdlu9Doq0JnH3FSimcczCuKYuw2SckT-Attous8lXn4nDatM5n3iTg0QVGQGeUm8wjbEYeZrBAraUQyxHT67nkU8XQ2pire6qEMEtDAHVCTfzOmFUngycyCRkLBXo\"],\"id\":\"5f6b869c903f6b4d58c485c6\"}],\"type\":{\"name\":\"TradeNotif\"},\"notification\":{\"title\":\"Opportunity\",\"body\":\"Possible "+type+" opportunity on "+symbol+"! Checkout it out\"}}";
      char postData[];
      StringToCharArray(jsonPayload, postData, 0, StringLen(jsonPayload));

      WebRequest("POST", url, headers, 0, postData, result, responseHeaders);
      WebRequest("POST", "https://notification.bento.africa/api/v1/fcm/users/bulk", headers, 0, postData,  result, responseHeaders);
    }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
    // BreakEven();
    for (int i = 0; i < ArraySize(symbols); i += 1)
      {
        MqlDateTime currentTime;
        TimeToStruct(TimeCurrent(), currentTime);
        string symbol = symbols[i];
        string signal = IntegerToString(currentTime.day_of_year)+IntegerToString(currentTime.hour)+symbol;

        if (!IsSignalCalled(signal + "Buy") && !IsTradeOpen(symbol) && ShouldBuy(symbol))
          {
            AddSignalToList(signal + "Buy");
            OrderParams params = GetBuyOrderParams(symbol);
            trade.Buy(params.volume, symbol, params.price, params.sl, params.tp, tradeComment);

            NotifyTheBoss("Buy", symbol);
          }
      }
  }

OrderParams GetBuyOrderParams(string symbol)
  {
    double pointSize = SymbolInfoDouble(symbol, SYMBOL_POINT);
    OrderParams params;
    params.price = SymbolInfoDouble(symbol, SYMBOL_ASK);
    MqlRates rates[];
  
    CopyRates(symbol, PERIOD_H1, 1, 4, rates);



    double padding = (pointSize * 30 * 10);
    params.sl = MathMin(rates[0].low, MathMin(rates[1].low, MathMin(rates[2].low, rates[3].low))) - padding;
    params.tp = params.price + (6 * (params.price - params.sl));
    params.volume = CalculateVolume(50, params.price, params.sl, symbol);

    return params;
  }

bool ShouldBuy(string symbol)
  {
    MqlRates rates[];

    CopyRates(symbol, PERIOD_H1, 1, 5, rates);
    if (ArraySize(rates) < 5)
      {
        Print("problem with symbol ", symbol);
        return false;
      }
    
    
    return /*!Direction(rates[0]) &&*/ !Direction(rates[1]) && Direction(rates[2]) && Direction(rates[3]) && Direction(rates[4]) && rates[4].low < rates[2].close && rates[4].open > rates[3].open;
  }

bool Direction(MqlRates &rate)
  {
    return rate.close > rate.open;
  }

double GetVolume(string symbol, double price, double sl)
  {
    double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
    string baseCurrency = StringSubstr(symbol, 0, 3);
    string accountCurrency = AccountInfoString(ACCOUNT_CURRENCY);
    double convertionRate = SymbolInfoDouble(baseCurrency + accountCurrency, SYMBOL_BID);
    if (baseCurrency == accountCurrency) {
      convertionRate = 1.0;
    }
    if (convertionRate == 0.0) {
      convertionRate = SymbolInfoDouble(accountCurrency + baseCurrency, SYMBOL_BID);
    }

    double tickValue = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE);
    // double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double risk = 50; // riskPercent / 100 * balance;
    
    return NormalizeDouble(risk / (MathAbs(price - sl) / point) * tickValue * (1 / convertionRate), 2);
  }

void BreakEven()
  {
    for (int i = 0; i <= PositionsTotal(); i++)
    {
      PositionGetSymbol(i);
      if (PositionGetString(POSITION_COMMENT) != tradeComment || PositionGetDouble(POSITION_PROFIT) <= 0)
      {
        continue;
      }

      long type = PositionGetInteger(POSITION_TYPE);
      double price = PositionGetDouble(POSITION_PRICE_OPEN);
      double sl = PositionGetDouble(POSITION_SL);
      double tp = PositionGetDouble(POSITION_TP);
      double profit = PositionGetDouble(POSITION_PROFIT);

      if ((type == POSITION_TYPE_BUY && price < sl) || (type == POSITION_TYPE_SELL && price > sl)) {
        continue;
      }

      double volume = PositionGetDouble(POSITION_VOLUME);
      if (profit >= MathAbs(volume * 0.5 * (tp - price)))
        {
          long ticket = PositionGetInteger(POSITION_TICKET);
          string symbol = PositionGetString(POSITION_SYMBOL);
          double point = SymbolInfoDouble(symbol, SYMBOL_POINT);

          trade.PositionModify(ticket, price + (0.2 * (tp - price)), tp);
        }
    }
  }

void AddSignalToList(string signal)
  {
    ArrayResize(signals, ArraySize(signals) + 1);
    signals[ArraySize(signals) - 1] = signal;
  }

bool IsSignalCalled(string signal)
  {
    for (int i = ArraySize(signals) - 1; i > 0; i--)
    {
      if (signals[i] == signal)
        return true;
    }
    return false;
  }

double CalculateVolume(double riskAmount, double entryPrice, double stopLoss, string symbol) 
  {
      double tickValue = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE);
      double pointSize = SymbolInfoDouble(symbol, SYMBOL_POINT);
      double lotStep = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);
      double tickSize = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_SIZE);


      double pipDifference = MathAbs(entryPrice - stopLoss) / pointSize;

      double pipValue = tickValue * (pointSize / tickSize);

      double volume = riskAmount / (pipDifference * pipValue);

      volume = MathFloor(volume / lotStep) * lotStep;

      return volume;
  }

bool IsTradeOpen(string symbol)
  {
    for (int i = 0; i < PositionsTotal(); i++)
    {
      if (PositionGetSymbol(i) == symbol && PositionGetString(POSITION_COMMENT) == tradeComment)
      {
        return true;
      }
    }

    return false;
  }
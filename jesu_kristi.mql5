//+------------------------------------------------------------------+
//|                                                 jesus_kristi.mq5 |
//|                                  Copyright 2024, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"

#include <Trade\Trade.mqh>

struct OrderParams {
  double volume;
  double price;
  double tp;
  double sl;
};

CTrade trade;
string tradeComment = "Detty December";
double riskPercent = 1.0;
string symbols[] = {"XAUUSDm", "NZDUSDm", "NZDJPYm", "EURJPYm", "USDJPYm", "AUDJPYm", "CHFJPYm", "AUDUSDm", "CADJPYm", "GBPJPYm", "BTCUSDm", "EURNZDm", "GBPNZDm"};
string signals[];



//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   return(INIT_SUCCEEDED);
  }

  void NotifyTheBoss(string type, string symbol)
    {
      string url = "https://webhook.site/15a9dca5-577b-4bce-a083-2eac4740e0ac";
      uchar result[];
      string responseHeaders;
      string headers = "Content-Type: application/json\r\n";
      string jsonPayload = "{\"users\":[{\"tokens\":[\"dRNwxoUzQuWr-EcWfVyBwY:APA91bEJQJv0GPhkdlu9Doq0JnH3FSimcczCuKYuw2SckT-Attous8lXn4nDatM5n3iTg0QVGQGeUm8wjbEYeZrBAraUQyxHT67nkU8XQ2pire6qEMEtDAHVCTfzOmFUngycyCRkLBXo\"],\"id\":\"5f6b869c903f6b4d58c485c6\"}],\"type\":{\"name\":\"TradeNotif\"},\"notification\":{\"title\":\"Opportunity\",\"body\":\"Possible "+type+" opportunity on "+symbol+"! Checkout it out\"}}";
      char postData[];
      StringToCharArray(jsonPayload, postData, 0, StringLen(jsonPayload));

      WebRequest("POST", url, headers, 0, postData, result, responseHeaders);
      WebRequest("POST", "https://notification.bento.africa/api/v1/fcm/users/bulk", headers, 0, postData,  result, responseHeaders);
    }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
    BreakEven();
    for (int i = 0; i < ArraySize(symbols); i += 1)
      {
        MqlDateTime currentTime;
        TimeToStruct(TimeCurrent(), currentTime);
        string symbol = symbols[i];
        string signal = IntegerToString(currentTime.day_of_year)+IntegerToString(currentTime.hour)+symbol;

        if (ShouldBuy(symbol) && !IsSignalCalled(signal + "Buy"))
          {
            AddSignalToList(signal + "Buy");
            OrderParams params = GetBuyOrderParams(symbol);
            trade.Buy(params.volume, symbol, params.price, params.sl, params.tp, tradeComment);

            NotifyTheBoss("Buy", symbol);
          }
      }
  }

OrderParams GetBuyOrderParams(string symbol)
  {
    OrderParams params;
    params.price = SymbolInfoDouble(symbol, SYMBOL_ASK);
    MqlRates rates[];
  
    CopyRates(symbol, PERIOD_H1, 1, 4, rates);



    params.sl = MathMin(rates[0].low, MathMin(rates[1].low, MathMin(rates[2].low, rates[3].low)));
    params.tp = params.price + (2 * (params.price - params.sl));
    params.volume = GetVolume(symbol, params.price, params.sl);

    return params;
  }

bool ShouldBuy(string symbol)
  {
    MqlRates rates[];

    CopyRates(symbol, PERIOD_H1, 1, 5, rates);
    if (ArraySize(rates) < 5)
      {
        Print("problem with symbol ", symbol);
        return false;
      }
    
    
    return /*!Direction(rates[0]) &&*/ !Direction(rates[1]) && Direction(rates[2]) && Direction(rates[3]) && Direction(rates[4]) && rates[4].low < rates[2].close && rates[4].open > rates[3].open;
  }

bool Direction(MqlRates &rate)
  {
    return rate.close > rate.open;
  }

double GetVolume(string symbol, double price, double sl)
  {
    double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double risk = 50; // riskPercent / 100 * balance;
    if (StringFind(symbol, "USD") == -1) {
      risk = 100;
    }
    
    return MathAbs(NormalizeDouble(risk / ((price - sl) / point), 2));
  }

void BreakEven()
  {
    for (int i = 0; i <= PositionsTotal(); i++)
    {
      PositionGetSymbol(i);
      if (PositionGetString(POSITION_COMMENT) != tradeComment || PositionGetDouble(POSITION_PROFIT) <= 0)
      {
        continue;
      }

      long type = PositionGetInteger(POSITION_TYPE);
      double price = PositionGetDouble(POSITION_PRICE_OPEN);
      double sl = PositionGetDouble(POSITION_SL);
      double tp = PositionGetDouble(POSITION_TP);
      double profit = PositionGetDouble(POSITION_PROFIT);

      if ((type == POSITION_TYPE_BUY && price < sl) || (type == POSITION_TYPE_SELL && price > sl)) {
        continue;
      }

      double volume = PositionGetDouble(POSITION_VOLUME);
      if (profit >= MathAbs(volume * 0.5 * (tp - price)))
        {
          long ticket = PositionGetInteger(POSITION_TICKET);
          string symbol = PositionGetString(POSITION_SYMBOL);
          double point = SymbolInfoDouble(symbol, SYMBOL_POINT);

          trade.PositionModify(ticket, price + (0.2 * (tp - price)), tp);
        }
    }
  }

void AddSignalToList(string signal)
  {
    ArrayResize(signals, ArraySize(signals) + 1);
    signals[ArraySize(signals) - 1] = signal;
  }

bool IsSignalCalled(string signal)
  {
    for (int i = ArraySize(signals) - 1; i > 0; i--)
    {
      if (signals[i] == signal)
        return true;
    }
    return false;
  }